********Row with maximum no. of zeroes******** 2643
class Solution {
public:
    vector<int> rowAndMaximumOnes(vector<vector<int>>& mat) {
        int m = mat.size();
        int n = mat[0].size();

        int prevCount = 0;   // maximum count seen so far
        int currCount = 0;   // count for current row
        int index = 0;       // row index with maximum ones

        for(int i = 0; i < m; i++){
            currCount = 0;   // reset for this row

            for(int j = 0; j < n; j++){
                if(mat[i][j] == 1)
                    currCount++;
            }

            // if this row has more ones, update
            if(currCount > prevCount){
                prevCount = currCount;
                index = i;
            }
        }

        return {index, prevCount};
    }
};
************** Lucky Number in matrix**********  1380
class Solution {
public:
    vector<int> luckyNumbers (vector<vector<int>>& matrix) {
        int m = matrix.size();
        int n = matrix[0].size();
        vector<int> ans;

        for(int i = 0; i < m; i++){
            // Step 1: find min element in row i
            int minVal = INT_MAX;
            int colIdx = -1;

            for(int j = 0; j < n; j++){
                if(matrix[i][j] < minVal){
                    minVal = matrix[i][j];
                    colIdx = j;
                }
            }

            // Step 2: check if it's max in that column
            bool isMax = true;
            for(int k = 0; k < m; k++){
                if(matrix[k][colIdx] > minVal){
                    isMax = false;
                    break;
                }
            }

            if(isMax) ans.push_back(minVal);
        }

        return ans;
    }
};
*******apply operation to an array********2460
class Solution {
public:
    vector<int> applyOperations(vector<int>& nums) {
        int n = nums.size();
        for(int i=0; i<n-1; i++){//O(n)
            if(nums[i]==nums[i+1]){
                //multiply and insert at nums[i]
                nums[i]=2*nums[i];
                nums[i+1]=0;
            }
        }
        //now move all zeroes to the end of array two pointer
        int left=0;
        for(int right=0; right<n; right++){
            if(nums[right]!=0){
                swap(nums[left],nums[right]);
                left++;
            }
        }
        return nums;
    }
};
*********Maximum average subArray I*********643
class Solution {
public:
    double findMaxAverage(vector<int>& nums, int k) {
        int n = nums.size();

        double sum = 0;
        for(int i = 0; i < k; i++){
            sum += nums[i];
        }

        double maxavg = sum / k;

        for(int i = k; i < n; i++){
            sum += nums[i] - nums[i - k]; // slide window
            maxavg = max(maxavg, sum / k);
        }

        return maxavg;
    }
};
**********Sliding subarray beauty********2653
class Solution {     //approach--->I
public:
    vector<int> getSubarrayBeauty(vector<int>& nums, int k, int x) {

        vector<int> ans;
        int n = nums.size();

        for(int i = 0; i <= n - k; i++) {

            // collect elements of current window
            vector<int> window;
            for(int j = i; j < i + k; j++) {
                window.push_back(nums[j]);
            }

            // sort the window
            sort(window.begin(), window.end());

            // we need x-th smallest NEGATIVE number
            int negCount = 0;
            int beauty = 0;  // default

            for(int val : window) {
                if(val < 0) {
                    negCount++;
                    if(negCount == x) {
                        beauty = val;
                        break;
                    }
                }
            }

            ans.push_back(beauty);
        }

        return ans;
    }
};


