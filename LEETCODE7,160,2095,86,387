class Solution {
public:
    int reverse(int x) {
      int reversed=0;
      while(x!=0){
        int digit=x%10;
        if(reversed>INT_MAX/10 || reversed<INT_MIN/10){//checking the range of interger for overflow and underflow of integer range
            return 0;
        }
        reversed= reversed*10+ digit;
        x /=10;
      }  
      return reversed;
    }
};
*************intersection two linked list***************
//will do it with finding the length approach and hashing approach
class Solution {
public:
    ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) {
        ListNode* temp1=headA;
        ListNode* temp2=headB;
        while(temp1!=temp2){
            temp1=temp1->next;
            temp2=temp2->next;
            if(temp1==temp2){//if find intersection or both reaches NULL
                return temp1;
            }
            if(temp1==NULL){
                temp1=headB;
            }
            if(temp2==NULL){
                temp2=headA;
        }
        }
        return temp1;//both pointing to same head
    }
};
***********Delete Middle Node of a LinkedList**********
class Solution {
public:
    ListNode* deleteMiddle(ListNode* head) {
        if(head==NULL || head->next==NULL){
            return NULL;
        }
        ListNode* temp=head;
        ListNode* prev=head;
        int count=0;
        while(temp!=NULL){
            temp=temp->next;
            count++;
        }
        long long int mid=count/2;
        for(int i=0; i<mid-1; i++){
            prev=prev->next;
        }
        prev->next=prev->next->next;
        //delete temp;
        return head;
    }
};
*************Partition List*******************
class Solution {
public:
    ListNode* partition(ListNode* head, int x) {
        
        ListNode* temp1=head;
        ListNode* dummy1= new ListNode(0);
        ListNode* small=dummy1;
        ListNode* dummy2= new ListNode(0);
        ListNode* large= dummy2;
        while(temp1!=NULL){
            if(temp1->val<x){
            small->next=temp1;
            small=small->next;
        }
        else{
            large->next=temp1;
            large=large->next;
        }
        temp1=temp1->next;
        }
        small->next=dummy2->next;
         large->next=NULL;
         return dummy1->next;
    }
};
***********First Unique character in a string**************
class Solution {
public:
    int firstUniqChar(string s) {
      char arr[26]={0};
      int n=s.length();
      for(int i=0; i<n; i++){
        char ch=s[i];
        arr[ch-'a']++;
      }
      for(int i=0; i<n; i++){
        char ch=s[i];
        if(arr[ch-'a'] == 1){
            return i;
        }
      }
      return -1;
    }
};
