********Longest Substring without repeating character*************--->leetcode:3
  class Solution {
public:
    int lengthOfLongestSubstring(string s) {
        unordered_map<char, int> lastindex;
        int maxlength=0;
        int left=0;
        for(int right=0; right<s.length(); right++){
        if(lastindex.count(s[right]) && lastindex[s[right]] >= left){
          left = lastindex[s[right]]+1;
          // if already present in map and in range
        }
       
            lastindex[s[right]] = right;//push index in map
            maxlength = max(maxlength,right-left+1);
        }
        return maxlength;
    }
};
************subarray with k different integers*************992
class Solution {
public:
int atMostK(vector<int>& nums, int K) {
    unordered_map<int,int> freq;
    int left = 0, ans = 0;

    for(int right = 0; right < nums.size(); right++) {
        freq[nums[right]]++;

        while(freq.size() > K) {
            freq[nums[left]]--;
            if(freq[nums[left]] == 0)
                freq.erase(nums[left]);
            left++;
        }

        ans += (right - left + 1);
    }
    return ans;
}
    int subarraysWithKDistinct(vector<int>& nums, int k) {
        return atMostK(nums, k) - atMostK(nums, k - 1);
    }
};
********Maximum point you can obatin from cards**********
class Solution {   T.C O(k)------>sliding window
public:
    int maxScore(vector<int>& cardPoints, int k) {
        int n = cardPoints.size();
        int currSum = 0;

        // Take first k cards from left
        for (int i = 0; i < k; i++)
            currSum += cardPoints[i];

        int maxSum = currSum;
        int right = n - 1;

        // Replace left cards with right cards
        for (int i = k - 1; i >= 0; i--) {
            currSum -= cardPoints[i];
            currSum += cardPoints[right];
            right--;
            maxSum = max(maxSum, currSum);
        }

        return maxSum;
    }
};
approach II --------> totalsum - minsumArray
class Solution {
public:
    int maxScore(vector<int>& cardPoints, int k) {
        int n = cardPoints.size();
        int totalSum = 0;

        for(int x : cardPoints)
            totalSum += x;

        if(k == n)
            return totalSum;

        int windowSize = n - k;
        int windowSum = 0;

        for(int i = 0; i < windowSize; i++)
            windowSum += cardPoints[i];

        int minWindowSum = windowSum;

        for(int i = windowSize; i < n; i++) {
            windowSum += cardPoints[i];
            int outerindex=i - windowSize;
            windowSum -= cardPoints[outerindex];
            minWindowSum = min(minWindowSum, windowSum);
        }

        return totalSum - minWindowSum;
    }
};
*******Minimum window substring*************76
class Solution {
public:
    string minWindow(string s, string t) {
        int n = s.length();
        if(t.length()>n){
            return "";
        }
        unordered_map<char,int> mp;
        for(char &ch: t){
            mp[ch]++;
        }
        int requiredcount=t.length();
        int i=0, j=0;
        int minwindowsize=INT_MAX;
        int start_i=0;
        while(j<n){
            char ch = s[j];
            if(mp[ch]>0)
            requiredcount--;
            mp[ch]--;
            while(requiredcount==0){
                //start shrinking the window
                int currwindow=j-i+1;
                if(minwindowsize>currwindow){
                    minwindowsize=currwindow;
                    start_i=i;
                }
                mp[s[i]]++;
                if(mp[s[i]]>0){
                    requiredcount++;
                }
                i++;
            }
           j++;
        }
    return minwindowsize == INT_MAX ? "":s.substr(start_i,minwindowsize);
    }
};




   
