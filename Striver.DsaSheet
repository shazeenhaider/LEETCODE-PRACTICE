********Longest Substring without repeating character*************--->leetcode:3
  class Solution {
public:
    int lengthOfLongestSubstring(string s) {
        unordered_map<char, int> lastindex;
        int maxlength=0;
        int left=0;
        for(int right=0; right<s.length(); right++){
        if(lastindex.count(s[right]) && lastindex[s[right]] >= left){
          left = lastindex[s[right]]+1;
          // if already present in map and in range
        }
       
            lastindex[s[right]] = right;//push index in map
            maxlength = max(maxlength,right-left+1);
        }
        return maxlength;
    }
};
************subarray with k different integers*************992
class Solution {
public:
int atMostK(vector<int>& nums, int K) {
    unordered_map<int,int> freq;
    int left = 0, ans = 0;

    for(int right = 0; right < nums.size(); right++) {
        freq[nums[right]]++;

        while(freq.size() > K) {
            freq[nums[left]]--;
            if(freq[nums[left]] == 0)
                freq.erase(nums[left]);
            left++;
        }

        ans += (right - left + 1);
    }
    return ans;
}
    int subarraysWithKDistinct(vector<int>& nums, int k) {
        return atMostK(nums, k) - atMostK(nums, k - 1);
    }
};
********Maximum point you can obatin from cards**********
class Solution {   T.C O(k)------>sliding window
public:
    int maxScore(vector<int>& cardPoints, int k) {
        int n = cardPoints.size();
        int currSum = 0;

        // Take first k cards from left
        for (int i = 0; i < k; i++)
            currSum += cardPoints[i];

        int maxSum = currSum;
        int right = n - 1;

        // Replace left cards with right cards
        for (int i = k - 1; i >= 0; i--) {
            currSum -= cardPoints[i];
            currSum += cardPoints[right];
            right--;
            maxSum = max(maxSum, currSum);
        }

        return maxSum;
    }
};
approach II --------> totalsum - minsumArray
class Solution {
public:
    int maxScore(vector<int>& cardPoints, int k) {
        int n = cardPoints.size();
        int totalSum = 0;

        for(int x : cardPoints)
            totalSum += x;

        if(k == n)
            return totalSum;

        int windowSize = n - k;
        int windowSum = 0;

        for(int i = 0; i < windowSize; i++)
            windowSum += cardPoints[i];

        int minWindowSum = windowSum;

        for(int i = windowSize; i < n; i++) {
            windowSum += cardPoints[i];
            int outerindex=i - windowSize;
            windowSum -= cardPoints[outerindex];
            minWindowSum = min(minWindowSum, windowSum);
        }

        return totalSum - minWindowSum;
    }
};




   
