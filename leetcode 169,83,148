************* MAJORITY ELEMENT ****************
//BRUTE FORCE TC:O(n^2)
class Solution {
  public:
    int majorityElement(vector<int>& arr) {
        int n = arr.size();
        for (int i = 0; i < n; i++) {
            int count = 0;
            // Count how many times arr[i] appears
            for (int j = 0; j < n; j++) {
                if (arr[j] == arr[i]) {
                    count++;
                }
            }
            // Check if it is the majority
            if (count > n / 2)
                return arr[i];
        }

        // No majority element found
        return -1;
    }
};
*********remove duplicate from sorted linked list*****
class Solution {
public:
    ListNode* deleteDuplicates(ListNode* head) {
        if(head==NULL){
            return NULL;
        }
        ListNode* temp=head;
        while(temp!=NULL && temp->next!=NULL){
            if(temp->val == temp->next->val){
                temp->next=temp->next->next;
            }
            else
            temp=temp->next;
        }
        return head;
    }
};
*****************Merge sort on Linked List*******************
class Solution {
public:
    ListNode* merge(ListNode* left, ListNode* right) {
        if (left == NULL) return right;
        if (right == NULL) return left;

        ListNode* ans = new ListNode(-1);  // dummy node
        ListNode* temp = ans;

        while (left != NULL && right != NULL) {
            if (left->val < right->val) {
                temp->next = left;
                left = left->next;
            } else {
                temp->next = right;
                right = right->next;
            }
            temp = temp->next;  // âœ… always move temp forward
        }

        // Attach the remaining nodes
        if (left != NULL) temp->next = left;
        if (right != NULL) temp->next = right;

        return ans->next;  // skip dummy node
    }

    ListNode* sortList(ListNode* head) {
        if (head == NULL || head->next == NULL) return head;

        // Find middle using slow-fast pointer
        ListNode* slow = head;
        ListNode* fast = head->next;

        while (fast != NULL && fast->next != NULL) {
            slow = slow->next;
            fast = fast->next->next;
        }

        // Split into two halves
        ListNode* mid = slow->next;
        slow->next = NULL;

        ListNode* left = sortList(head);
        ListNode* right = sortList(mid);

        // Merge sorted halves
        return merge(left, right);
    }
};

  
