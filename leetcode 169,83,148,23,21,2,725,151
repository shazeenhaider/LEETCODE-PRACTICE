************* MAJORITY ELEMENT ****************
//BRUTE FORCE TC:O(n^2)
class Solution {
  public:
    int majorityElement(vector<int>& arr) {
        int n = arr.size();
        for (int i = 0; i < n; i++) {
            int count = 0;
            // Count how many times arr[i] appears
            for (int j = 0; j < n; j++) {
                if (arr[j] == arr[i]) {
                    count++;
                }
            }
            // Check if it is the majority
            if (count > n / 2)
                return arr[i];
        }

        // No majority element found
        return -1;
    }
};
*********remove duplicate from sorted linked list*****
class Solution {
public:
    ListNode* deleteDuplicates(ListNode* head) {
        if(head==NULL){
            return NULL;
        }
        ListNode* temp=head;
        while(temp!=NULL && temp->next!=NULL){
            if(temp->val == temp->next->val){
                temp->next=temp->next->next;
            }
            else
            temp=temp->next;
        }
        return head;
    }
};
*****************Merge sort on Linked List*******************
class Solution {
public:
    ListNode* merge(ListNode* left, ListNode* right) {
        if (left == NULL) return right;
        if (right == NULL) return left;

        ListNode* ans = new ListNode(-1);  // dummy node
        ListNode* temp = ans;

        while (left != NULL && right != NULL) {
            if (left->val < right->val) {
                temp->next = left;
                left = left->next;
            } else {
                temp->next = right;
                right = right->next;
            }
            temp = temp->next;  // âœ… always move temp forward
        }

        // Attach the remaining nodes
        if (left != NULL) temp->next = left;
        if (right != NULL) temp->next = right;

        return ans->next;  // skip dummy node
    }

    ListNode* sortList(ListNode* head) {
        if (head == NULL || head->next == NULL) return head;

        // Find middle using slow-fast pointer
        ListNode* slow = head;
        ListNode* fast = head->next;

        while (fast != NULL && fast->next != NULL) {
            slow = slow->next;
            fast = fast->next->next;
        }

        // Split into two halves
        ListNode* mid = slow->next;
        slow->next = NULL;

        ListNode* left = sortList(head);
        ListNode* right = sortList(mid);

        // Merge sorted halves
        return merge(left, right);
    }
};
**************Merge K sorted lists ****************
class Solution {
public:
    ListNode* merge(ListNode* left, ListNode* right) {
        if (left == NULL) return right;
        if (right == NULL) return left;

        ListNode* ans = new ListNode(-1);  
        ListNode* temp = ans;

        while (left != NULL && right != NULL) {
            if (left->val < right->val) {
                temp->next = left;
                left = left->next;
            } else {
                temp->next = right;
                right = right->next;
            }
            temp = temp->next;  
        }

        // Attach the remaining nodes
        if (left != NULL) temp->next = left;
        if (right != NULL) temp->next = right;

        return ans->next;  
    }
    ListNode* partitionAndmerge(int start, int end,vector<ListNode*>&lists){
        if(start>end){
            return NULL;
        }
        if(start==end){
            return lists[start];
        }
        int mid= start+(end-start)/2;
        ListNode* L1= partitionAndmerge(start,mid,lists);
        ListNode* L2=partitionAndmerge(mid+1,end,lists);
        return merge(L1,L2);
    }
    ListNode* mergeKLists(vector<ListNode*>& lists) {
        int k=lists.size();
        if(k==0){
            return NULL;
        }
        return partitionAndmerge(0,k-1,lists);
    }
};
*************Merge two sorted list*************
class Solution {
public:
    ListNode* mergeTwoLists(ListNode* left, ListNode* right) {
        if (left == NULL) return right;
        if (right == NULL) return left;

        ListNode* ans = new ListNode(-1);  
        ListNode* temp = ans;

        while (left != NULL && right != NULL) {
            if (left->val < right->val) {
                temp->next = left;
                left = left->next;
            } else {
                temp->next = right;
                right = right->next;
            }
            temp = temp->next;  
        }

        // Attach the remaining nodes
        if (left != NULL) temp->next = left;
        if (right != NULL) temp->next = right;

        return ans->next;  
    }
};
****************add two number **************
class Solution {
public:
    ListNode* addTwoNumbers(ListNode* l1, ListNode* l2) {
        ListNode* head = NULL;
        ListNode* tail = NULL;
        int carry = 0;

        while (l1 != NULL || l2 != NULL || carry != 0) {
            int sum = carry;

            if (l1 != NULL) {
                sum += l1->val;
                l1 = l1->next;
            }

            if (l2 != NULL) {
                sum += l2->val;
                l2 = l2->next;
            }

            carry = sum / 10;
            int digit = sum % 10;

            ListNode* newNode = new ListNode(digit);

            // If this is the first node
            if (head == NULL) {
                head = newNode;
                tail = newNode;
            } else {
                tail->next = newNode;
                tail = tail->next;
            }
        }

        return head;
    }
};
************split linked list in K pairs*************
class Solution {
public:
    vector<ListNode*> splitListToParts(ListNode* head, int k) {
        ListNode* temp=head;
        ListNode* prev=NULL;
        int length=0;
        while(temp!=NULL){
            length++;//length of the linked list
            temp=temp->next;
        }
        vector<ListNode*> result(k,NULL);
        int eachNode=length/k;
        int remainderNode=length%k;
        temp=head;//reinitialise to head
        for(int i=0; i<k && temp!=NULL;i++){//tracking no. of pairs
            result[i]=temp;
            for(int count=1; count<=eachNode+(remainderNode>0?1:0);count++){
                prev=temp;
                temp=temp->next;
            }
            prev->next=NULL;
            remainderNode--;//reducing the remainder after add to one pair 
        }
    return result;
}
};
  **********reverse Word In a String**************
class Solution {
public:
    string reverseWords(string s) {
        int n=s.length();
        string ans = "";
        reverse(s.begin(),s.end());
        for(int i=0; i<n; i++){
            string word= "";
            while(i<n && s[i]!=' '){
                word += s[i];
                i++;
            }
            reverse(word.begin(),word.end());
            if(word.length()>0){//valid word not empty check for repeating ''
             ans += " "+word;
            }
        }
        return ans.substr(1);
    }
};
