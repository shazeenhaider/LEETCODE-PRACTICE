class Solution {
public:
    int missingNumber(vector<int>& nums) {
         long int n = nums.size();//value of integer
        long int total= n * (n+1)/2;//sum n interger formula
        long int sum=0;
        for(int i=0; i<nums.size(); i++){
            sum += nums[i];
        }
        return total-sum;
    }
};
**************Linked List cycle***************//circular linked list exists or not
class Solution {
public:
    bool hasCycle(ListNode* head) {
        ListNode* slow=head;
        ListNode* fast=head;
        while(fast!=NULL && fast->next!=NULL){
            slow=slow->next;
            fast=fast->next->next;
            if(slow==fast){
                return true;
            }
        }
        return false;
    }
};
************circular linkedlist II**************//node where the linkedlist start
class Solution {
public:
    ListNode *detectCycle(ListNode *head) {
        ListNode* slow=head;
        ListNode* fast=head;
        bool isCycle=false;
        while(fast!=NULL && fast->next!=NULL){
            slow=slow->next;
            fast=fast->next->next;
            if(slow==fast){
                isCycle=true;
                break;
        }
        }
       if(!isCycle){
        return NULL;
       }
       slow =head;
       while(slow!=fast){
        slow=slow->next;
        fast=fast->next;
       }
    return slow;
    }
};
*************Odd Even Linked List************
class Solution {
public:
    ListNode* oddEvenList(ListNode* head) {
        if(head==NULL){
            return NULL;
        }
        ListNode* odd=head;
        ListNode* even=head->next;
        ListNode* evenHead=even;
        int count=0;
        while(even!=NULL && even->next!=NULL){
                odd->next=even->next;
                odd=odd->next;
                even->next=odd->next;
                even=even->next;
            }
         odd->next=evenHead;
         return head;
    }
};
************Middle of a Linked List************
class Solution {
public:
    ListNode* middleNode(ListNode* head) {
        if(head==NULL){
            return NULL;
        }
        ListNode* slow=head;
        ListNode* fast=head;
        //ListNode* temp=head;
        while(fast!=NULL && fast->next!=NULL){
            slow=slow->next;
            fast=fast->next->next;

        }
    return slow;
    }
};
*********REmove elment in vector/array************
class Solution {
public:
    int removeElement(vector<int>& nums, int val) {
        int index=0;//two pointer approach
        for(int i=0; i<nums.size(); i++){
            if(nums[i]!=val){
                nums[index]=nums[i];//move the element to fist index
                index++;//counting the elements
            }
        }
        return  index;
    }
};
*************Length Of Last Characters***************
class Solution {
public:
    int lengthOfLastWord(string s) {
        int n=s.length()-1;
        int count=0;
        while(n>=0 && s[n]==' '){//removing last spaces 
            n--;
        }
        for(int i=n; i>=0; i--){//reverse loop to iterate last 
          if(s[i]!=' '){
            count++;
           }
           else
             break;
        }
        return count;
    }
};
