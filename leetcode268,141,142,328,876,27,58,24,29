class Solution {
public:
    int missingNumber(vector<int>& nums) {
         long int n = nums.size();//value of integer
        long int total= n * (n+1)/2;//sum n interger formula
        long int sum=0;
        for(int i=0; i<nums.size(); i++){
            sum += nums[i];
        }
        return total-sum;
    }
};
**************Linked List cycle***************//circular linked list exists or not
class Solution {
public:
    bool hasCycle(ListNode* head) {
        ListNode* slow=head;
        ListNode* fast=head;
        while(fast!=NULL && fast->next!=NULL){
            slow=slow->next;
            fast=fast->next->next;
            if(slow==fast){
                return true;
            }
        }
        return false;
    }
};
************circular linkedlist II**************//node where the linkedlist start
class Solution {
public:
    ListNode *detectCycle(ListNode *head) {
        ListNode* slow=head;
        ListNode* fast=head;
        bool isCycle=false;
        while(fast!=NULL && fast->next!=NULL){
            slow=slow->next;
            fast=fast->next->next;
            if(slow==fast){
                isCycle=true;
                break;
        }
        }
       if(!isCycle){
        return NULL;
       }
       slow =head;
       while(slow!=fast){
        slow=slow->next;
        fast=fast->next;
       }
    return slow;
    }
};
*************Odd Even Linked List************
class Solution {
public:
    ListNode* oddEvenList(ListNode* head) {
        if(head==NULL){
            return NULL;
        }
        ListNode* odd=head;
        ListNode* even=head->next;
        ListNode* evenHead=even;
        int count=0;
        while(even!=NULL && even->next!=NULL){
                odd->next=even->next;
                odd=odd->next;
                even->next=odd->next;
                even=even->next;
            }
         odd->next=evenHead;
         return head;
    }
};
************Middle of a Linked List************
class Solution {
public:
    ListNode* middleNode(ListNode* head) {
        if(head==NULL){
            return NULL;
        }
        ListNode* slow=head;
        ListNode* fast=head;
        //ListNode* temp=head;
        while(fast!=NULL && fast->next!=NULL){
            slow=slow->next;
            fast=fast->next->next;

        }
    return slow;
    }
};
*********REmove elment in vector/array************
class Solution {
public:
    int removeElement(vector<int>& nums, int val) {
        int index=0;//two pointer approach
        for(int i=0; i<nums.size(); i++){
            if(nums[i]!=val){
                nums[index]=nums[i];//move the element to fist index
                index++;//counting the elements
            }
        }
        return  index;
    }
};
*************Length Of Last Characters***************
class Solution {
public:
    int lengthOfLastWord(string s) {
        int n=s.length()-1;
        int count=0;
        while(n>=0 && s[n]==' '){//removing last spaces 
            n--;
        }
        for(int i=n; i>=0; i--){//reverse loop to iterate last 
          if(s[i]!=' '){
            count++;
           }
           else
             break;
        }
        return count;
    }
};
*****************Swap Nodes in Pairs**************
class Solution {
public:
    ListNode* swapPairs(ListNode* head) {//RECURSIVE APPROACH
        if(head==NULL || head->next==NULL){
            return head;
        }
        ListNode* temp=head->next;
        head->next=swapPairs(head->next->next);
        temp->next=head;
        return temp;
    }
};
************Iterative Approach***********
class Solution {
public:
    ListNode* swapPairs(ListNode* head) {
        if (head == NULL || head->next == NULL) {
            return head;
        }

        // new head will be the 2nd node after first swap
        ListNode* newHead = head->next;

        ListNode* temp1 = head;          // first node of the pair
        ListNode* temp2 = head->next;    // second node of the pair
        ListNode* prevTail = NULL;       // tail of previous swapped pair

        while (temp1 != NULL && temp2 != NULL) {
            ListNode* nextPair = temp2->next; // store next pair start

            // swap the pair
            temp2->next = temp1;
            temp1->next = nextPair;

            // connect previous swapped pair with current swapped pair
            if (prevTail != NULL) {
                prevTail->next = temp2;
            }

            // move pointers ahead
            prevTail = temp1;
            temp1 = nextPair;
            if (temp1 != NULL) {
                temp2 = temp1->next;
            } else {
                temp2 = NULL;
            }
        }

        return newHead;
    }
};
*************Divide two integer*******************
class Solution {
public:
    int divide(int dividend, int divisor){
        // int quotient;
        // if(divisor!=0){
        //  quotient = dividend/divisor;integer part return 
        // }
        // return quotient;directly 
        // //we need to do this using long division
        // //take care of integer overflow
        if(dividend==divisor){
            return 1;
        }
        bool sign =true;
        if(dividend>=0 && divisor<0){
            sign = false;
        }
        if(dividend<=0 && divisor>0){
            sign = false;
        }
        long n = abs((long)dividend);//int data type to long positive using abs()
        long d = abs((long)divisor);
        divisor=abs((long)divisor);
        long quotient =0;
        while(n>=d){
            int count=0;
            while( n>=( d <<(count + 1))){
                count +=1;
            }
            quotient += 1<<count;
            n -= (d<<count);
        }
        if(quotient==(1<<31) && sign){
            return INT_MAX;
        }
        if(quotient==(1<<31)&& !sign){
            return INT_MIN;
        }
        return sign? quotient : -quotient;
    }
};
