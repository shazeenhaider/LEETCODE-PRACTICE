*********Binary Search *********** //T.C=O(log n)
class Solution {
public:
    int search(vector<int>& arr, int target) {
        int st=0;
        int end=arr.size()-1;
        while(st<=end){
            int mid = st+(end-st)/2;//overflow condition
            if(arr[mid]==target){
                return mid;
            }
            else if(arr[mid]<target){
               st= mid+1;//rigth side;
            }
            else if(arr[mid]>target){
                end=mid-1;//left side
            }
        }
        return -1;//not present target
    }
};
**********Spiral Matrix*************
class Solution {
public:
    vector<int> spiralOrder(vector<vector<int>>& matrix) {
        int m = matrix.size();
        int n = matrix[0].size();

        int srow = 0, scol = 0;
        int erow = m - 1, ecol = n - 1;

        vector<int> ans;

        while (srow <= erow && scol <= ecol) {

            // top row
            for (int i = scol; i <= ecol; i++)
                ans.push_back(matrix[srow][i]);

            // right column
            for (int j = srow + 1; j <= erow; j++)
                ans.push_back(matrix[j][ecol]);

            if (srow < erow) {
                // bottom row
                for (int i = ecol - 1; i >= scol; i--)
                    ans.push_back(matrix[erow][i]);
            }

            if (scol < ecol) {
                // left column
                for (int j = erow - 1; j > srow; j--)
                    ans.push_back(matrix[j][scol]);
            }

            // move boundaries
            srow++;
            scol++;
            erow--;
            ecol--;
        }

        return ans;
    }
};

