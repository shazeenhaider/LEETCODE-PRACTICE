*********Binary Search *********** //T.C=O(log n)
class Solution {
public:
    int search(vector<int>& arr, int target) {
        int st=0;
        int end=arr.size()-1;
        while(st<=end){
            int mid = st+(end-st)/2;//overflow condition
            if(arr[mid]==target){
                return mid;
            }
            else if(arr[mid]<target){
               st= mid+1;//rigth side;
            }
            else if(arr[mid]>target){
                end=mid-1;//left side
            }
        }
        return -1;//not present target
    }
};
**********Spiral Matrix*************
class Solution {
public:
    vector<int> spiralOrder(vector<vector<int>>& matrix) {
        int m = matrix.size();
        int n = matrix[0].size();

        int srow = 0, scol = 0;
        int erow = m - 1, ecol = n - 1;

        vector<int> ans;

        while (srow <= erow && scol <= ecol) {

            // top row
            for (int i = scol; i <= ecol; i++)
                ans.push_back(matrix[srow][i]);

            // right column
            for (int j = srow + 1; j <= erow; j++)
                ans.push_back(matrix[j][ecol]);

            if (srow < erow) {
                // bottom row
                for (int i = ecol - 1; i >= scol; i--)
                    ans.push_back(matrix[erow][i]);
            }

            if (scol < ecol) {
                // left column
                for (int j = erow - 1; j > srow; j--)
                    ans.push_back(matrix[j][scol]);
            }

            // move boundaries
            srow++;
            scol++;
            erow--;
            ecol--;
        }

        return ans;
    }
};
***********Spiral Matrix II **************
class Solution {
public:
    vector<vector<int>> generateMatrix(int n) {
        int siz= n;//size of each vector
        vector<vector<int>> matrix(n , vector<int>(n));
        
        int srow=0, scol=0;
        int erow=n-1, ecol=n-1;
        int num=1;
        while(srow<=erow && scol<=ecol){
        for(int i=scol; i<=ecol; i++){
            matrix[srow][i]=num++;
        }
        for(int i=srow+1; i<=erow; i++){
            matrix[i][ecol]=num++;
        }
        for(int i=ecol-1; i>=scol; i--){
            matrix[erow][i]=num++;
        }
        for(int i=erow-1; i>=srow+1; i--){
            matrix[i][scol]=num++;
        }
        srow++, scol++;
        erow--, ecol--;
        }
        return matrix;
    }
};
********* sort colors***********
class Solution {
public:
    void sortColors(vector<int>& nums) {
        int low = 0, mid = 0, high = nums.size() - 1;

        while(mid <= high) {
            if(nums[mid] == 0) {
                swap(nums[mid], nums[low]);
                low++;
                mid++;
            }
            else if(nums[mid] == 1) {
                mid++;
            }
            else { // nums[mid] == 2
                swap(nums[mid], nums[high]);
                high--;
            }
        }
    }
};
**********Median of the two sorted array*************
class Solution {
public:
    double findMedianSortedArrays(vector<int>& nums1, vector<int>& nums2) {
        int st1 = 0, st2 = 0;
        vector<int> ans;

        // merge two sorted arrays
        while(st1 < nums1.size() && st2 < nums2.size()){
            if(nums1[st1] < nums2[st2])
                ans.push_back(nums1[st1++]);
            else
                ans.push_back(nums2[st2++]);
        }

        while(st1 < nums1.size())
            ans.push_back(nums1[st1++]);

        while(st2 < nums2.size())
            ans.push_back(nums2[st2++]);

        int n = ans.size();
        
        // find median
        if(n % 2 == 1)
            return ans[n/2];
        else
            return (ans[n/2 - 1] + ans[n/2]) / 2.0;
    }
};
****************Search in 2D Matrix I ********** Must be in T.C O(log(n*m))
class Solution {
public:
    bool searchMatrix(vector<vector<int>>& matrix, int target) {
        //binary search  approach;
        //T.C O(log(n*m));
        int m = matrix.size();//no. of row 
        int n = matrix[0].size();//no. of column
        int start=0, end=m*n-1;
        while(start<=end){
            int mid= start+(end-start)/2;
            if(matrix[mid/n][mid%n]==target){
                return true;
            }
            else if(matrix[mid/n][mid%n]>target){
                end= mid-1;
            }
            else{
                start= mid +1;//down
            }
        }
        return false;
    }
};
          
 
************search in 2d matrix II *********
class Solution {
public:
    bool searchMatrix(vector<vector<int>>& matrix, int target) {
        //staircase approach;
        //T.C O(n+m);
        int m = matrix.size();//no. of row 
        int n = matrix[0].size();//no. of column
        int i=0, j=n-1;//i-->row j-->column
        while(i<m && j>=0){
            if(matrix[i][j]==target){
                return true;
            }
            else if(matrix[i][j]>target){
                j--;//move to left
            }
            else{
                i++;//down
            }
        }
        return false;
    }
};
***********Rotate array*********
class Solution {
public:
    void rotate(vector<int>& nums, int k) {
        int m = nums.size();
        k = k%m;//handle large k if k larger the than size of array
        reverse(nums.begin(),nums.end());//full reverse
        int end=m-1;
        int  st=k;//move start to k
        reverse(nums.begin(),nums.begin() + k);//reverse first k element
       while(st<end){//reversing the remaining element
        swap(nums[st],nums[end]);
        st++;
        end--;
       }
    }
};
************Contigous subarray***********525
class Solution {
public:
    int findMaxLength(vector<int>& nums) {
        int n=nums.size();
       unordered_map<int, int> mp;
       int currsum=0;
       mp[0]=-1;
       int result=0;
       for(int i=0; i<n; i++){
         currsum += (nums[i]==1)? 1:-1;
         if(mp.find(currsum)!=mp.end()){
            result= max(result, i-mp[currsum]);
         }
         else{
            mp[currsum]=i;
         }
       }

     return result;
    }
};
